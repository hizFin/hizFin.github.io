{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이사 완료 블로그 이사가 끝났다. 기존 jekyll 테마(ruby 기반)를 사용하고 있었는데 Apple Silicon M1에서 계속 말썽을 일으켜서 gatsby 테마(react 기반)로 이사를 했다. 새로운 집은 이미 공사가 완료된 아파트로 정했다. (빈 공터에서 집을 짓기에는 능력부족) 👍🏼 gatsby-starter-hoodie 👍🏼   이번 이사과정을 …","fields":{"slug":"/first-post/"},"frontmatter":{"date":"June 17, 2023","title":"🚛 이사 완료","tags":["blog","gatsby"]},"rawMarkdownBody":"\n## 이사 완료\n\n블로그 이사가 끝났다.\n\n기존 jekyll 테마(ruby 기반)를 사용하고 있었는데 Apple Silicon M1에서 계속 말썽을 일으켜서  \ngatsby 테마(react 기반)로 이사를 했다.\n\n새로운 집은 이미 공사가 완료된 아파트로 정했다. (빈 공터에서 집을 짓기에는 능력부족)  \n👍🏼 [gatsby-starter-hoodie](https://github.com/devHudi/gatsby-starter-hoodie) 👍🏼  \n\n\n이번 이사과정을 간략하게 나마 정리해서 올릴 예정이다.  \n이제 글도 꾸준히 올리고 화이팅 해야겠다!\n\n\n\n"},{"excerpt":"기본 요소 요소 내용 예시 예시 설명 비고 ^ 시작의 의미 ^This This로 시작하는 문자열  ^ not [^This] This로 시작하지 않는 문자열  $ 끝의 의미 year$ year로 끝나는 문자열  ? 0개 또는 1개 a-zA-Z?   + 1개 이상 a-zA-Z+   * 0개 이상 a-zA-Z*   {n} n개 a-zA-Z{2}   {n,} n…","fields":{"slug":"/[010]basic regex/"},"frontmatter":{"date":"February 12, 2023","title":"[Sql] 정규식 패턴 기본 요소","tags":["sql","oracle","postgresql","정규식","regex","regexp"]},"rawMarkdownBody":"![](010_01.png)\n\n\n\n## 기본 요소\n\n| 요소                      | 내용          | 예시 |      예시 설명|비고|\n|:-----------------------------|:-----------------|:--------|:--------|:--------|\n| ^          | 시작의 의미     | ^This |This로 시작하는 문자열||\n| ^          | not     | \\[^This] | This로 시작하지 않는 문자열||\n| $          | 끝의 의미     | year$ | year로 끝나는 문자열||\n| ?          | 0개 또는 1개     | [a-zA-Z]? |||\n| +          | 1개 이상     | [a-zA-Z]+ |||\n| *          | 0개 이상     | [a-zA-Z]* |||\n| {n}          | n개     | [a-zA-Z]{2} |||\n| {n,}          | n개 이상 | [a-zA-Z]{2,} |||\n| {n,m}          | n개 이상, m개 이하     | [a-zA-Z]{2,3} |||\n| (a\\|b\\|c)         | a 또는 b 또는 c     |  |||\n| [abc]         | a 또는 b 또는 c     |  |||\n| [a-c]         | a 또는 b 또는 c     |  |||\n| [a-zA-Z]         | 영문자(대소문자)     |  ||\n| [0-9]         | 숫자     |  ||\n| \\d         | 숫자   |  ||대문자입력시 반대 의미|\n| \\w         | 문자(숫자+영문자+언더바(_))     ||  |대문자입력시 반대 의미|\n| \\s         | 공백문자(개행포함)     |  ||대문자입력시 반대 의미|\n| \\t         | 탭문자     |  ||\n| \\n         | 개행문자     |  ||\n| .         | 문자(모든))     |  |\n| \\숫자        | 앞에 n번째 패턴     | ([abc])([가나다])\\1\\2 | 1번째,2번째,1번째,2번째패턴 \n| \\b문자열\\b         | 해당 문자열<br>(처음과 끝은 \\w로 감싸임X))    | \\b(abc)\\b |\n| \\B문자열\\B         | 해당 문자열<br>(처음과 끝은 \\w로 감싸임O)    | \\B(abc)\\B |\n\n\n## 참고 사이트\n1. <https://regex101.com>  (테스트 해보기 좋음)\n"},{"excerpt":"OVER() 함수의 기본적인 사용법을 알아보자 OVER() 함수 _ 기본  PRECEDING, FOLLOWING 사용 PRECEDING, FOLLOWING을 사용하여 range(row 또는 기간)를 설정할 수 있다.","fields":{"slug":"/[009]over() function (preceding, following)/"},"frontmatter":{"date":"February 06, 2023","title":"[Sql] OVER() 함수 (PRECEDING, FOLLOWING 사용))","tags":["sql","oracle","postgresql","함수","preceding","following","over"]},"rawMarkdownBody":"![](009_01.png)\n\n\nOVER() 함수의 기본적인 사용법을 알아보자\n\n## OVER() 함수 _ 기본\n\n```sql\nSELECT A.ENAME\n,      A.JOB\n,      A.HIREDATE\n,      A.SAL\n,      SUM(A.SAL)       OVER(ORDER BY A.JOB, A.SAL, A.ENAME)    -- 누적합계(정렬기준에 따라)\n,      FIRST_VALUE(SAL) OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 첫번째 값\n,      LAST_VALUE(SAL)  OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 마지막 값\n,      LEAD(SAL)        OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 다음 row 값\n,      LAG(SAL)         OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 이전 row 값\n,      RANK()           OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- RANK\n,      DENSE_RANK()     OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- RANK_중복 순위 이후에 순차적 증가  \n,      ROW_NUMBER()     OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- ROW_NUMBER\n,      CUME_DIST()      OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 직업별 누적분포(급여순)\n,      PERCENT_RANK()   OVER(PARTITION BY A.JOB ORDER BY A.SAL) -- 직업별 백분위(급여순)\n,      AVG(CASE WHEN A.SAL > 1000 THEN A.SAL END) OVER(PARTITION BY A.JOB) -- CASE문을 활용한 over()\nFROM S_MGA.EMP A\nORDER BY A.JOB, A.SAL, A.ENAME\n```\n\n![](009_02.png)\n\n\n## PRECEDING, FOLLOWING 사용\n\nPRECEDING, FOLLOWING을 사용하여 range(row 또는 기간)를 설정할 수 있다.\n\n```sql\n\n/*\n \n회사의 성적이 좋아 새로운 조건들로 급여인상을 진행한다.\n\n조건\nCASE1(NEW_SAL_BY_ROW)   : 본인보다 먼저 고용된 인원 2명의 급여를 비교하여 가장 최댓값으로 산정(직업별) \nCASE2(NEW_SAL_BY_MONTH) : 본인보다 24개월 먼저 고용된 인원의 급여를 비교하여 가장 최댓값으로 산정(직업별)\n\n*/\n\nSELECT A.ENAME\n,      A.JOB\n,      A.HIREDATE\n,      A.SAL  -- 기존월급\n, MAX(A.SAL) OVER(PARTITION BY A.JOB         -- 직업별\n                ORDER       BY A.HIREDATE\n                ROWS BETWEEN 2 PRECEDING     -- 이전 2ROW \n                     AND     0 FOLLOWING     -- 이후 0ROW\n                ) AS NEW_SAL_BY_ROW          -- BY 본인보다 먼저 고용된 인원 인원급여 이용한 새로운 월급 \n, MAX(A.SAL) OVER(PARTITION BY A.JOB         -- 직업별\n                ORDER       BY A.HIREDATE \n                RANGE BETWEEN INTERVAL '24' MONTH PRECEDING  -- 24개월 이전 \n                      AND     INTERVAL '0'  MONTH FOLLOWING  -- 0개월 이후\n                ) AS NEW_SAL_BY_MONTH        -- BY 본인보다 24개월 내 먼저 고용된 인원급여 이용한 새로운 월급  \nFROM S_MGA.EMP A\nORDER BY A.JOB, A.HIREDATE\n```\n\n![](009_03.png)\n\n"},{"excerpt":"postgresql로 나누기를 할 때 결과값의 소수점이 절삭되는 경우가 있다. 어떻게 하면 온전하게 값이 출력되는지 알아보자  Postgres 아래에서는 상수를 기입했지만 일반적으로는 컬럼으로 대입하게 되는데 이런 경우를 봤을 때 이 더욱 유용하게 쓰이겠다. 번외 (Oracle은?) 기본적으로 절삭되지 않는다.","fields":{"slug":"/[008]division in postgres/"},"frontmatter":{"date":"January 24, 2023","title":"[Postgres] 나누기 결과값의 소수점이 절삭되는 경우","tags":["postgresql","tip"]},"rawMarkdownBody":"![](008_01.png)\n\n\npostgresql로 나누기를 할 때 결과값의 소수점이 절삭되는 경우가 있다.  \n어떻게 하면 온전하게 값이 출력되는지 알아보자 \n\n## Postgres\n\n아래에서는 상수를 기입했지만 일반적으로는 컬럼으로 대입하게 되는데 이런 경우를 봤을 때 `::decimal`이 더욱 유용하게 쓰이겠다.\n```sql\nSELECT 2/3                    AS COL1 -- 0\n,      CAST(2/3 AS NUMERIC)   AS COL2 -- 0\n,      CAST(2 AS NUMERIC) / 3 AS COL5 -- 0.66666666666666666667\n,      2./3                   AS COL3 -- 0.66666666666666666667\n,      2/3.                   AS COL4 -- 0.66666666666666666667\n,      2/3 ::DECIMAL          AS COL6 -- 0.66666666666666666667\n;\n```\n\n\n## 번외 (Oracle은?)\n\n기본적으로 절삭되지 않는다.\n```sql\nSELECT 2/3 AS COL1   -- 0.6666666666666666666666666666666666666667\nFROM DUAL;\n```\n"},{"excerpt":"정규식 이용하여 SQL쿼리 소스테이블 한번에 찾기 찾는 문자열 문자열 내용 :  결과","fields":{"slug":"/[006]how to find source table name by regex/"},"frontmatter":{"date":"January 10, 2023","title":"[Sql] 정규식 이용하여 SQL쿼리 소스테이블 한번에 찾기","tags":["sql","tip","정규식","oracle","postgresql","tibero"]},"rawMarkdownBody":"\n![](006_01.png)\n\n\n### 정규식 이용하여 SQL쿼리 소스테이블 한번에 찾기\n\n- 찾는 문자열\n  \n```text\n(FROM|JOIN)[ \\t\\r\\n\\v\\f]+[a-zA-Z]\n```\n\n- 문자열 내용 : `[FROM 또는 JOIN] & [공백,탭,개행]1개이상 & [영문자]`\n\n- 결과\n![img2](006_02.png)\n\n\n"},{"excerpt":"마크다운 공백 입력 문자별 적용유무 비교 A앞에 를 사용했습니다. -> (O)                A A앞에 를 사용했습니다. -> (X)            A A앞에 를 사용했습니다. -> (O)                A 전각문자 사용법  대괄호 안에 있는 전각문자를 복사/붙여넣기","fields":{"slug":"/[005]whitespace in markdown/"},"frontmatter":{"date":"January 09, 2023","title":"[Markdown] 마크다운 공백 입력 방법 (전각문자 활용)","tags":["markdown","tip","공백","전각문자"]},"rawMarkdownBody":"\n![](005_01.png)\n\n\n### 마크다운 공백 입력 문자별 적용유무 비교\n\n1. A앞에 `전각문자`를 사용했습니다. -> **(O)**  \n               A\n\n2. A앞에 `스페이스바`를 사용했습니다. -> **(X)**  \n               A\n\n3. A앞에 `&nbsp;`를 사용했습니다. -> **(O)**  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A\n\n#### 전각문자 사용법\n`[ ]` 대괄호 안에 있는 전각문자를 복사/붙여넣기  \n\n"},{"excerpt":"계정생성 권한 부여 (TABLESPACE 할당에 관한) 이유 : DML 작업 간  발생 TABLESPACE 접근권한 확인 DDL(Create) Script DML(Insert) Script","fields":{"slug":"/[004]sample ddl, dml script/"},"frontmatter":{"date":"January 05, 2023","title":"[Oracle] 샘플 테이블 DDL, DML script","tags":["oracle","sql","샘플","샘플테이블","ddl","dml"]},"rawMarkdownBody":"\n![](004_01.png)\n\n## 계정생성\n```sql\nCREATE USER [계정명] IDENTIFIED BY [패스워드];\n```\n\n## 권한 부여 (TABLESPACE 할당에 관한)\n이유 : DML 작업 간 ``ORA-01950: 테이블스페이스 'DATA'에 대한 권한이 없습니다.`` 발생\n```sql\nALTER USER [계정명] QUOTA UNLIMITED ON [테이블스페이스명];\n```\n\n## TABLESPACE 접근권한 확인\n```sql\nSELECT * \nFROM   DBA_TS_QUOTAS \nWHERE  1=1\nAND    USERNAME = [계정명];\n```\n\n\n## DDL(Create) Script\n```sql\n\n/*----DDL 스크립트 목록-----\n1. EMP (직원정보) / 7\n-----------------------*/\n\n\n\n/*------DDL script -----\n1. EMP (직원정보)\n-----------------------*/\n\n\n-- DROP TABLE S_FNA.EMP CASCADE CONSTRAINTS PURGE;\n\nCREATE TABLE S_FNA.EMP (\nEMPNO NUMBER NOT NULL,\nENAME VARCHAR (10) ,\nJOB VARCHAR (10) ,\nMGR NUMBER ,\nHIREDATE DATE ,\nSAL NUMBER ,\nCOMM NUMBER \n) TABLESPACE DATA LOGGING NOCOMPRESS;\nCREATE UNIQUE INDEX S_FNA.EMP_PK ON S_FNA.EMP ( EMPNO) TABLESPACE DATA LOGGING;\nALTER TABLE S_FNA.EMP ADD CONSTRAINT EMP_PK PRIMARY KEY(\nEMPNO\n) USING INDEX S_FNA.EMP_PK;\n\n\nCOMMENT ON TABLE S_FNA.EMP IS '직원정보';\nCOMMENT ON COLUMN S_FNA.EMP.EMPNO IS '직원번호';\nCOMMENT ON COLUMN S_FNA.EMP.ENAME IS '이름';\nCOMMENT ON COLUMN S_FNA.EMP.JOB IS '직업';\nCOMMENT ON COLUMN S_FNA.EMP.MGR IS '담당매니저';\nCOMMENT ON COLUMN S_FNA.EMP.HIREDATE IS '생일';\nCOMMENT ON COLUMN S_FNA.EMP.SAL IS '월급';\nCOMMENT ON COLUMN S_FNA.EMP.COMM IS '보너스';\n\n```\n\n## DML(Insert) Script\n\n```sql\n\n-- DML\n\nINSERT INTO S_MGA.EMP VALUES( 7839, 'KING', 'PRESIDENT', NULL, TO_DATE('1996-11-17','YYYY-MM-DD'), 5000, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7698, 'BLAKE', 'MANAGER', 7839, TO_DATE('1991-1-05','YYYY-MM-DD'), 2850, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7782, 'CLARK', 'MANAGER', 7839, TO_DATE('1999-9-06','YYYY-MM-DD'), 2450, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7566, 'JONES', 'MANAGER', 7839, TO_DATE('2001-02-04','YYYY-MM-DD'), 2975, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7788, 'SCOTT', 'ANALYST', 7566, TO_DATE('2003-06-17','YYYY-MM-DD'), 3000, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7902, 'FORD', 'ANALYST', 7566, TO_DATE('1981-03-12','YYYY-MM-DD'), 3000, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7369, 'SMITH', 'CLERK', 7902, TO_DATE('2007-12-1','YYYY-MM-DD'), 800, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7499, 'ALLEN', 'SALESMAN', 7698, TO_DATE('20-2-1981','DD-MM-YYYY'), 1600, 300);\nINSERT INTO S_MGA.EMP VALUES( 7521, 'WARD', 'SALESMAN', 7698, TO_DATE('22-2-1981','DD-MM-YYYY'), 1250, 500);\nINSERT INTO S_MGA.EMP VALUES( 7654, 'MARTIN', 'SALESMAN', 7698, TO_DATE('28-9-1981','DD-MM-YYYY'), 1250, 1400);\nINSERT INTO S_MGA.EMP VALUES( 7844, 'TURNER', 'SALESMAN', 7698, TO_DATE('8-9-1981','MM-DD-YYYY'), 1500, 0);\nINSERT INTO S_MGA.EMP VALUES( 7876, 'ADAMS', 'CLERK', 7788, TO_DATE('13-7-87', 'DD-MM-YY'), 1100, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7900, 'JAMES', 'CLERK', 7698, TO_DATE('3-12-1981','MM-DD-YYYY'), 950, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7934, 'MILLER', 'CLERK', 7782, TO_DATE('2003-1-23','YYYY-MM-DD'), 1300, NULL);\nINSERT INTO S_MGA.EMP VALUES( 7610, 'MILLER', 'SALESMAN', 7698, TO_DATE('2013-12-01','YYYY-MM-DD'), 1300, NULL);\n\nCOMMIT;\n\n```\n"},{"excerpt":"GROUPING SETS 와 ROLLUP 비교  (+ GROUPING_ID) 차이점 : 소계합계를 구할 때 GROUPING SETS가 더 유연하게 내가 원하는 그룹만 추출할 수 있다. 1. GROUPING SETS 특징 특정 그룹별로 소계/합계 가능 예시) GROUP BY GROUPING SETS (A, B, C) : ->  +  +    전체 소계/합계…","fields":{"slug":"/[003]grouping sets vs rollup(grouping_id)/"},"frontmatter":{"date":"January 04, 2023","title":"[Oracle] GROUPING SETS 와 ROLLUP 비교 (+ GROUPING_ID)","tags":["oracle","sql","grouping sets","rollup","grouping_id"]},"rawMarkdownBody":"\n![](003_01.png)\n\n## GROUPING SETS 와 ROLLUP 비교  (+ GROUPING_ID)\n\n차이점 : 소계합계를 구할 때 GROUPING SETS가 더 유연하게 내가 원하는 그룹만 추출할 수 있다.\n\n### 1. GROUPING SETS\n\n#### 특징\n1. 특정 그룹별로 소계/합계 가능\n- 예시) GROUP BY GROUPING SETS (A, B, C)  \n  : -> `(A) 소계/합계` + `(B) 소계/합계` + `(C) 소계/합계`  \n  \n2. 전체 소계/합계 추출 시 ``()`` 입력해야 함\n- 예시) GROUP BY GROUPING SETS (JOB, ENAME, ``()``)  \n\n#### SQL\n```sql\nSELECT \n      CASE WHEN GROUPING_ID(A.ENAME) = '1' AND GROUPING_ID(A.JOB) = '1' \n                 -- GROUPING_ID : 해당 값이 NULL 이면 '1' , NOT NUL 이면 '0' 반환\n      \t   THEN '합계'\n      \t   ELSE A.ENAME\n      END AS ENAME\n,      A.JOB\n,      SUM(A.SAL)\n,      COUNT(1)\nFROM S_MGA.EMP A \nGROUP BY GROUPING SETS(JOB, (ENAME,JOB), ()) -- (JOB), (ENAME, JOB), (전체)의 소계/합계\nORDER BY CASE WHEN ENAME = '합계' THEN 3\n              WHEN ENAME IS NULL THEN 2\n              WHEN ENAME IS NOT NULL THEN 1\n         END, ENAME, A.JOB\n```\n![sql1 result](003_02.png)\n\n### 2. ROLLUP\n\n#### 특징 \n1. ROLLUP() 함수 내 **컬럼 기입 순서**에 따라 그루핑이 달라짐\n- 명시한 컬럼과 순서가 결과에 영향을 끼치며 그룹을 묶을 때 가장 오른쪽 부터 하나씩 소거해간다.  \n- 예시) GROUP BY ROLLUP (A, B, C)  \n  : -> `(A,B,C) 소계/합계` + `(A,B) 소계/합계` + `(A) 소계/합계` + `(전체) 소계/합계`  \n\n1. 전체 소계/합계 자동 추출\n- 따로 명시하지 않아도 자동으로 추출 됨\n\n#### SQL\n```sql\nSELECT \n       CASE WHEN GROUPING_ID(A.ENAME) = '1' AND GROUPING_ID(A.JOB) = '1'\n                 -- GROUPING_ID : 해당 값이 NULL 이면 '1' , NOT NUL 이면 '0' 반환\n       \t   THEN '합계'\n       \t   ELSE A.ENAME\n       END AS ENAME\n,      A.JOB\n,      SUM(A.SAL)\n,      COUNT(1)\nFROM S_MGA.EMP A \nGROUP BY ROLLUP(JOB, ENAME) -- (JOB,ENAME), (JOB), (전체)의 소계 합계 \nORDER BY A.ENAME, A.JOB\n```\n![sql2 result](003_02.png)\n    \n"},{"excerpt":"인덱스 테이블의 칼럼에 대해 생성되는 객체로 별도의 공간에 컬럼값들을 정렬한 후 생성 데이터를 빨리 찾기위해서 사용( ROWID(오라클에서 실제 레코드, 행이 있는 물리적 주소)를 찾은 후 실제 원본 데이터를 빠르게 접근) 테이블의 기본키를 생성하면 자동으로 고유 인덱스로 생성됨. 이름처럼 중복값이 있다면 ROWID 정렬 만약 값에 null이 존재한다면 …","fields":{"slug":"/[002]index/"},"frontmatter":{"date":"November 14, 2022","title":"[Oracle] 기초강의 : 01.인덱스","tags":["oracle","sql"]},"rawMarkdownBody":"\n# 인덱스\n\n- 테이블의 칼럼에 대해 생성되는 객체로 별도의 공간에 컬럼값들을 정렬한 후 생성\n- 데이터를 빨리 찾기위해서 사용( ROWID(오라클에서 실제 레코드, 행이 있는 물리적 주소)를 찾은 후 실제 원본 데이터를 빠르게 접근)\n- 테이블의 기본키를 생성하면 자동으로 고유 인덱스로 생성됨.\n- 이름처럼 중복값이 있다면 ROWID 정렬\n- 만약 값에 null이 존재한다면 오름차순 정렬시 맨 뒤에 위치하며 null값은 인덱스에 포함되지 않음.\n    - 그래서 where COLNM IS NULL을 사용하면 COLNM 인덱스를 경유하지 않음.\n\n## 인덱스 종류 (01. 만드는 형태에 따라)\n\n### 단일인덱스\n- 하나의 컬럼 \n \n### 복합인덱스\n- 여러개의 컬럼  \n\n### 오름차순(내림차순) 인덱스\n\n### 함수기반 인덱스\n- SQL함수나 표현식에 생성  \n\n## 인덱스 종류 (02. 내부 구성에 따라)\n\n### B*Tree 인덱스\n- 일반적인 오라클 인덱스인 균형잡힌 트리 형태  \n\n### Bitmap인덱스\n- 비트를 이용하여 컬럼 값을 간결하게 저장  \n- or, not 함수 반응 좋음  \n\n### itmap Join 인덱스\n- 두 테이블 조인시 조인한 결과 칼럼에 대해 비트맵 인덱스를 생성  \n\n### 역전환키 인덱스\n- 인덱스 컬럼의 값을 역으로 변경하여 B*Tree 인덱스를 구성  \n\n## (더알아보기) B*Tree 인덱스\n\n- 오라클에서 만드는 인덱스는 비트리(B*Tree) 인덱스\n    - Tree구조와 유사\n    \n    ![](002_01.png)\n\n- 여러개 컬럼으로 구성한다면 첫번째 열, 선행 컬럼은 가장 자주 액세스 되며 유일한 값을 가지는 컬럼을 사용하는 것이 좋음\n\n\n**<💡> 입력 또는 수정이 빈번한 테이블에 많은 인덱스가 있는 경우 문제 생길 가능성 주의**\n\n\n- OR처럼 범위를 넓히면서 검색하는 경우 제성능 어려움\n- 특히 NOT을 사용하는 부정연산에 취약 (→ 비트맵인덱스에는 좋음)\n\n**<💡>  where, 조인절에 빈번히 출현하는 컬럼에 인덱스 적용필요**\n\n\n![](002_02.png)\n\n- 오라클이 판단하여 원본테이블 또는 index테이블에서 검색을 실시(대량이거나 인덱스가 존재한다면 대체로 index테이블 우선조회함)\n    - 힌트로 어느 테이블에서 조회할지 설정 가능"}]}},"pageContext":{}},"staticQueryHashes":[]}